#### Направете малък модул за работа с дати

За дата приемаме наредена тройка:
* година - число >= 1970
* месец - число от 1 до 12
* ден - число от 1 до X, където Х е броя дни в съответния месец

Направете подходяща структура Date, която съхранява данните за структурата.

В структурата сложете такива полета, каквито сметнете за добре. Едно от нещата, които искаме да постигнем в модула е да абстрахираме данните(полетата) в структурата от фунцкиите, които извличат или променят полезната информация в тях.

T.e. Не се интересуваме как точно е представена информацията за датата в структурата (може да са 3 полета за ден, месец и година, може да е [unix timestamp](https://en.wikipedia.org/wiki/Unix_time), може и да е едно число във вида DDMMYYY, или пък YYYYMMDD). Това, което е важно, е че чрез фунцкиите, които сме написали можем да извличаме от структурата и да манипулираме съществената информация за датата (ден, месец, година).

Това ни дава гъвкавостта да можем да променяме начина по който представяме данните в бъдеще и стига да запазим "интерфейса" на модула, всички които го ползват няма да бъдат засегнати. Т.е. написаните от нас фунцкии ще имат същите имена, същите параметри, ще връщат същите типове и ще вършат същата работа, макар и по различен начин (защото данните в структурата вече са различни). Така всичкия външен код, който използва модула ще остане коректен, защото не разчита на полетата на структурата, а само на фунцкиите, които манипулират нейните инстанции, а тяхната семантика не се променя.

За структурата Date направете следните фунцкии:

```c++
struct Date;

/*
	Връща инстанция на Date, която съдържа зададената дата day.month.year;
*/
Date create_date(unsigned int day, unsigned int month, unsigned int year);

/*
	Връща деня от месеца, записан в Date.
*/
unsigned int get_day(Date date);

/*
	Връща месеца, записан в Date.
*/
unsigned int get_month(Date date);

/*
	Връща годината, записана в Date.
*/
unsigned int get_year(Date date);

/*
	Променя деня от месеца, записан в инстанция на структурата на подадената стойност.
*/
void set_day(Date& date, unsigned int day);

/*
	Променя месеца, записан в инстанция на структурата на подадената стойност.
*/
void set_month(Date& date, unsigned int month);

/*
	Променя годината, записана в инстанция на структурата на подадената стойност.
*/
void set_year(Date& date, unsigned int year);

/*
	Проверява дали първата дата е преди втората дата. (Аналогично на <)
*/
bool before(Date first, Date second);

/*
	Проверява дали първата дата е след втората дата. (Аналогично на >)
*/
bool after(Date first, Date second);

/*
	Проверява дали две дати са еднакви.
*/
bool same(Date first, Date second);

/*
	Модифицира датата, така че да бъде с подадения брой дни напред.
*/
void add_days(Date& date, unsigned int days);

/*
	Модифицира датата, така че да бъде с подадения брой месеци напред.
*/
void add_months(Date& date, unsigned int months);

/*
	Модифицира датата, така че да бъде с подадения брой години напред.
*/
void add_years(Date& date, unsigned int years);

/*
	Отпечатва датата на stdout във формат dd.mm.yyyy
*/
void print_date(Date date);

```

##### Бонус

1. Гарантирайте, че всяка инстанция на структурата, която е създадена и обработвана **само** чрез написаните в модула съдържа валидна дата. За целта:

	1. При опит за създаване на невалидна дата чрез функцията `create_date`, върнета инстанция на Date, която съдържа датата 1.1.1970
	2. При опит за задаване на невалиден ден, месец или година в инстанция на структурата - игнорирайте промяната и не променяйте структурата

2. Направете фунцкии за изваждане на ден, месец и година, аналогични на тези за добавяне.

3. Добвете липсващите три фунцкии за сравнения на дати (аналогичните на <=, >= и !=)
