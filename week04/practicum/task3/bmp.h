#ifndef __BMP_H__
#define __BMP_H__

#include <cstdint>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>

#include "pixel.h"

using std::cerr;
using std::fstream;
using std::ios;

/**
 *  Клас, представляващ отворен файл, съдържащ bitmap изображение.
 *
 *  При създаването на обект се отваря подадения файл и съдържанието му се зарежда в паметта.
 *  При работа с класа промените се отразяват само в паметта.
 *  При унищожаване на обекта промените се записват на диска.
 */
class Bmp {
public:
    Bmp(const char* filename);
    ~Bmp();

    /**
     *  Изтриваме конструкторите за копиране.
     *  Няма смисъл да можем да копираме обект от класа, защото ако модифицираме едно и също
     *  изображение през два различни обекта, единия ще презапише промените на другия.
     */
    Bmp(const Bmp& other) = delete;
    Bmp& operator= (const Bmp& other) = delete;

    /**
     *  Прилага филтър негатив върху изображението
     */
    void negative();

    uint32_t getWidth() const;
    uint32_t getHeight() const;

    /**
     *  Връща пиксела на координати (x, y).
     *  Началото на координатната система (точка (0, 0)) се намира в левия горен ъгъл.
     *
     *  Извикващия функцията трябва да гарантира, че `x < width` и `y < height`.
     */
    const Pixel& getPixel(uint32_t x, uint32_t y) const;

    /**
     *  Задава стойност на пиксела на координати (x, y).
     *  Началото на координатната система (точка (0, 0)) се намира в левия горен ъгъл.
     *
     *  Извикващия функцията трябва да гарантира, че `x < width` и `y < height`.
     */
    void setPixel(uint32_t x, uint32_t y, const Pixel& pixel);

private:
    void save();

    fstream file;
    uint32_t dataOffset;
    uint32_t width;
    uint32_t height;

    // Има два варианта, по които можем да заредим масива от пиксели в паметта.
    //
    // Първият е да използваме голям едномерен масив `arr[WIDTH * HEIGHT]` (aka буфер).
    // Предимството е, че това съвпада с представянето във файла, поради което
    // можем само с по едно извикване на read и write да прочитаме и записваме
    // цялото изображение. Недостатъка е, че ако искаме да достъпим пиксел с точно
    // определени координати трябва първо да му пресметнем индекса.
    //
    // Вторият вариант е да използваме двумерен масив `arr[WIDTH][HEIGHT]`.
    // Но така ще трябва да си заделяме и освобождаваме двумерен динамичен масив, а и
    // четенето и писането в файла ще стават чрез цикъл, които обхожда редовете пиксели.
    //
    // Избрах първия вариант, защото е по-лесен и бърз, но втория може да се пробва като
    // упражнение.
    Pixel* pixelArray;
};

#endif
