#ifndef __TASK_LIST_H__
#define __TASK_LIST_H__

#include <iostream>
#include <vector>
#include "task.h"

class TaskList {
public:
    bool add(const Task& task);
    bool remove(const char* taskName);

    // Практика в C++ е, когато създаваме getter, през който искаме да можем и да четем и да
    // променяме определена член данна, да създаваме функция с два overload-а.
    //
    // Единият връща неконстантна референция, т.е. чрез него можем и да четем и да променяме
    // съдържанието на член данната, но може да се извиква само ако обекта ни или референцията
    // към него не е маркирана като константа.
    // `Foo& getFoo(...);`
    //
    // Другият връща константа референция, но може да се извиква винаги.
    // `const Foo& getFoo(...); const`
    //
    // В такъв случай ако не се опитваме да променим обекта, const версията ще се извиква с
    // приоритет. Пример:
    //
    // void f1(X& x) {
    //      cout << x.getFoo();     // връща const Foo&
    //      x.getFoo() = 20;        // връща Foo&, на който присвояваме стойност 20
    // }
    //
    // void f2(const X& x) {
    //      cout << x.getFoo();     // връща const Foo&
    //      x.getFoo() = 20;        // грешка при компилиране
    // }

    // Функцията `get` търси за задача със зададеното име в списъка.
    // Ако такава съществува връща указател към нея.
    // Ако такава не съществува връща NULL.
    //
    // Важно: върнатият указател ще е валиден докато списъка от задачи не се променя.
    // След промяна не трябва да се достъпва, защото може да е станал невалиден (например
    // защото задачата е била изтрита или защото вектора е презаделил памметта си на ново място).

    const Task* get(const char* taskName) const;
    Task* get(const char* taskName);

    void print(std::ostream& os) const;

private:
    size_t findIndex(const char* taskName) const;

    std::vector<Task> list;
};

#endif
