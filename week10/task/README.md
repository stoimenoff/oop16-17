# Battleships
Целта ни е да напишем конзолна версия на играта [Battleships](https://en.wikipedia.org/wiki/Battleship_(game)). Играта ще бъде player vs computer (singleplayer). За целта ще ни трябват няколко базови класа:

## Position
Описва позиция на дъската за кораби чрез номер на ред и колона. Номерирането започва от 0.

* `row()` - връща номера на реда
* `column()` - връща номера на колоната
* `delta_rows(const Position&)` - връща разликата в редовете между позицията и подадената позиция (винаги положително число)
* `delta_columns(const Position&)` - връща разликата в колоните между позицията и подадената позиция (винаги положително число)
* `is_adjacent_to(const Position&)` - указва дали подадената позиция е съседна. Съседите на една позиция са всички позиции около нея (най-много 8), както и самата позиция.
* `operator ==`
* `operator !=`

## BoardSize
Описва големината(размерите) на дъската за кораби чрез брой редове и брой колони. Дъската може да е правоъгълна, но трябва да съдържа поне 1 квадратче (поне 1 ред и поне 1 колона).

* `rows()` - връща броя редове на дъската
* `columns()` - връща броя колони на дъската
* `is_valid(const Position&)` - указва дали подадената позиция е валидна в дъската

## Ship::ShipPart
Структура, описваща част от кораб. Съдържа позицията на частта и булева стойност, която указва дали частта е била уцелена от противника.

## Ship
Описва кораб от бойното поле.

* `size()` - връща големината на кораба
* `all_parts()` - връща колекция (например std::vector) от всичките части на кораба.
* `is_sunk()` - указва дали кораба е потопен. Един кораб е потопен, ако всичките му части са уцелени.
* `lies_over(const Position&)` - указва дали някоя от частите на кораба се намира на подадената позиция.
* `fits_in(const BoardSize&)` - указва дали кораба се "побира" в дъска, с подадения размер.
* `colides_with(const Ship& other)` - указва дали кораба колизира с подадения кораб. С други думи, дали двата кораба могат едновременно да бъдат на дъската. Два кораба не могат да имат части на едни и същи или съседни позиции.
* `take_damage(const Position&)` - ако кораба има част разположена на подадената позиция, тя бива уцелена от противника.

## AttackBoard
Описва дъска с изстрели и техните резултати.

* `size()` - връща размерите на дъската
* `is_attacked(const Position&)` - указва дали подадената позиция е била атакувана
* `is_not_attacked(const Position&)` - указва дали подадената позиция не е била атакувана
* `is_hit(const Position&)` - указва дали на подадената позиция е бил уцелен кораб на опонента
* `is_miss(const Position&)` - указва дали подадената позиция е била атакувана, но не е уцелен кораб на опонента
* `mark_hit(const Position&)` - маркира подадената позиция като атакувана с уцелен кораб на нея
* `mark_miss(const Position&)` - маркира подадената позиция като атакувана, но без уцелен кораб на нея
* `is_valid_to_attack(const Position&)` - указва дали подадената позиция е валидна за атака. Една позиция не може да бъде атакувана два пъти.

## ShotResult
Описва резултата от направена атака.

* `hit()` - указва дали атаката е уцелила кораб
* `get_hit_ship()` - връща уцеления кораб, ако има такъв

## ShipBoard
Описва дъската, на която са разположени корабите.

* `size()` - връща размерите на дъската
* `sunk_ships_number()` - връща броя на потопените кораби на дъската
* `floating_ships_number()` - връща броя на непотопените кораби на дъската
* `all_sunk()` - указва дали всички кораби на дъската са потопени
* `get_ships()` - връща колекция(например std::vector) от всички кораби на дъската
* `shoot(const Position&)` - извършва атака по подадената позиция и връща резултата от удара (ShotResult)

## ShipsRequest
Описва заявка за създаване на кораби чрез брой кораби и големина на корабите. В началото на играта всеки играч получава колекция от заявки, спрямо която разполага корабите си.

* `quantity()` - връща броя на искани кораби
* `size()` - връща големината на исканите кораби

## Player
Абстрактен базов клас, който описва играч. Всеки играч може да прави две неща:
* да разполага корабите си в началото на играта, за което получава параметри - големината на дъската и описание на исканите кораби
* да избира къде да осъществи атака, когато е на ход. За целта получава две неща - AttackBoard, който съдържа досегашните му изстрели, както и ShipBoard, съдържащ неговите кораби(и техния статус съответно).

```c++
	virtual ShipBoard place_ships(const BoardSize& board_size, const std::vector<ShipRequest>& requests) = 0;
	virtual Position shoot(const AttackBoard& attacks, const ShipBoard& board) = 0;
```

***

_Всички предложени класове са примерни! Ако имате друга идея за направата на играта, можете да реализирате нея._
